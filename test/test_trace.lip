(**

  ⚠️ DISCLAIMER ⚠️

  This file is a template for testing the provided examples of Tiny Rust.

  These tests make a lot of assumptions about your code, therefore you have
  the option to adapt them to work with your implmentation, or vice versa,
  adapt your implementation to make it work with these tests.

  Here we assume that the [trace] function returns a [result] and
  never raises exceptions.

*)

open TinyrustLib
open Ast

(** ------------------------------------------
    Types & definitions
    ------------------------------------------ *)

type mut = Mutable | Immutable

type trace_error =
  | TypeError of string
  | UnboundVar of ide
  | CannotMutate of ide
  | MovedValue of ide
  | MutBorrowOfNonMut of ide
  | DataRace of ide * mut * mut
  | OutOfGas of int
  | NotInLoop

type 'output trace_result = ('output, trace_error) result
(** ['output] is a type parameter for successful executions *)


let examples_dir = "/absolute/path/to/tinyrust/examples/"

let read_file filename =
  let ch = open_in filename in
  let str = really_input_string ch (in_channel_length ch) in
  close_in ch;
  str

(** associative array, mapping filename to content *)
let examples_dict : (string * string) array =
  let examples = Sys.readdir examples_dir in
  Array.sort String.compare examples;
  Array.map (fun e -> (e, read_file (examples_dir ^ e))) examples

(** ------------------------------------------
    Helper functions
    ------------------------------------------ *)

let pr = Printf.printf

let spr = Printf.sprintf

let string_of_mut = function
  | Mutable -> "mutable"
  | Immutable -> "immutable"

let string_of_trace_error = function
  | TypeError s ->
      spr "[TypeError] %s" s
  | CannotMutate x ->
      spr "[CannotMutate] cannot mutate immutable variable %s" x
  | UnboundVar x ->
      spr "[UnboundVar] %s not defined in this scope" x
  | MovedValue x ->
      spr "[MovedValue] borrow of moved value %s" x
  | OutOfGas i ->
      spr "[OutOfGas] trace run out of gas (%d)" i
  | NotInLoop ->
    "[NotInLoop] cannot break outside of a loop"
  | MutBorrowOfNonMut x ->
      spr
        "[MutBorrowOfNonMut] cannot borrow %s as mutable, as it is not \
         declared as mutable"
        x
  | DataRace (x, mut1, mut2) ->
      spr "[DataRace] cannot borrow %s as %s because it is also borrowed as %s"
        x (string_of_mut mut1) (string_of_mut mut2)

    (* Note: a data race is when:
        - there are two or more references defined on
          the same variable, in the same scope,
        - one of them is mutable
    *)
[@@ocamlformat "disable"]

(** ------------------------------------------
    Definition of tests
    ------------------------------------------ *)

(* Feel free to increase or decrease the amount of steps (gas) *)

let tests : (string * int * string trace_result) array =
  [|
    ("01-print.rs",           25, Ok "3\n4\n");
    ("02-intError.rs",        25, Error (CannotMutate "x"));
    ("03-intOk.rs",           25, Ok "7\n");
    ("04-stringError.rs",     25, Error (UnboundVar "x"));
    ("05-stringOk.rs",        25, Ok "Ciao, mondo\n");
    ("06-scopeOk.rs",         25, Ok "6\n3\n");
    ("07-scopeError.rs",      25, Error (UnboundVar "y"));
    ("08-func.rs",            25, Ok "7\n");
    ("09-proc.rs",            25, Ok "7\n");
    ("10-ifThenElse.rs",             25, Ok "dispari\n");
    ("11-ownError.rs",        25, Error (MovedValue "x"));
    ("12-ownFnError.rs",      25, Error (MovedValue "x"));
    ("13-borrow.rs",          25, Ok "Ciao\nCiao\n");
    ("14-borrowFn.rs",        25, Ok "il parametro x: Ciao\nil parametro prestato: Ciao\n" );
    ("15-borrowError.rs",     25, Error (DataRace ("x", Mutable, Immutable)));
    ("16-borrowMut.rs",       25, Ok "Ciao, mondo\nCiao, mondo\n");
    ("17-borrowMutError.rs",  40, Error (MutBorrowOfNonMut "x"));
    ("18-loop.rs",            50, Error (OutOfGas 50));
    ("19-loopBreak.rs",       50, Ok "3\n2\n1\n0\n");
    ("20-loopNested.rs",      50, Ok "0,0\n0,1\n1,0\n1,1\n2,0\n2,1\n");
    ("21-exprBlock.rs",       25, Ok "7\n");
    ("22-funExpr.rs",         25, Error (UnboundVar "interna"));
    ("23-scopeCheck.rs",      25, Error (UnboundVar "y"));
  |] [@@ocamlformat "disable"]

(** ------------------------------------------
    Start of trace tests
    ------------------------------------------ *)

let%expect_test "test_trace" =
  Array.iter2
    (fun (name, prog) (_, gas, test) ->
      let prog : Ast.prog = Parser.parse_string prog in

      (* We're running the program and ignoring the trace list.
         because we only care about the outcome here (Ok or Error).

         If you used exceptions, use the [try .. with] construct here.
      *)
      let _, (res : string trace_result) = Trace.trace_prog gas prog in

      let icon =
        match (res, test) with
        | Ok _, Ok _ | Error _, Error _ -> "✔"
        | Ok _, Error _ | Error _, Ok _ -> "✘"
      in

      pr "------------------------\n%s %s\n------------------------\n" icon name;

      List.iter
        (fun (title, result) ->
          let kind, output =
            match result with
            | Ok output -> ("Ok", output)
            | Error err -> ("Error", string_of_trace_error err)
          in
          pr "%-9s %-9s\n%s\n\n" title kind output)
        [ ("Output:", res); ("Expected:", test) ])
    examples_dict tests
